---
layout: post
title: "[8.6] 클로저"
---

## 클로저

---

자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행한다. [8.5]

이를 활용하면 변수를 은닉하여 지속성을 보장하는 등의 다양한 기능을 구현할 수 있다.

```jsx
var a = "A";
function f() {
  var b = "B";
  function g() {
    var c = "C";
    console.log(a + b + c);
  }
  g();
}
f();
```

1. 함수 f를 호출할 때 함수 f의 렉시컬 환경 컴포넌트가 생성된다.
2. 그 후에 함수 g의 함수 선언문을 평가해서 함수 객체 생성. 이 함수 객체의 렉시컬 환경 컴포넌트에는 함수 g의 코드, 함수 f의 렉시컬 컴포넌트 참조, 전역 객체의 참조가 저장된다.
3. 함수 g를 호출해서 실행하면 그 시점에서 함수 g의 렉시컬 환경 컴포넌트를 생성한다. 동시에 함수 g의 실행 문맥의 외부 렉시컬 환경 참조를 통해 거슬러 올라가서 자유 변수 a와 b값을 참조한다.

함수 g의 함수 객체가 있는 동안에는 클로저 안의 모든 렉시컬 환경 컴포넌트를 함수 g의 함수 객체가 참조하므로 클로저는 가비지 컬렉션 대상이 되지 않는다.

## 클로저의 성질

---

'클로저는 캡슐화된 객체' 이다.

1. 외부 함수 makeCounter는 중첩 함수 f의 참조를 반환한다.
2. 중첩 함수 f는 외부 함수 makeCounter의 지역변수 count를 참조한다.
3. 함수 makeCounter의 렉시컬 환경 컴포넌트를 전역 변수 counter가 f의 함수 객체로 간접적으로 참조하게 되므로 가비지 컬렉션의 대상이 되지 않는다.
4. 변수 count는 크로저의 내부 상태로서 저장되므로 함수 바깥에서 읽거나 쓸수 없다. 또한 함수 f는 클로저의 내부 상태를 바꾸는 메서드 역할

```jsx
function makeCounter() {
	var count = 0;
	return f;
	function f() {
		return count++;
	}
}
var counter = makeCounter();
console.log((counter());  // 0
console.log((counter());  // 1
console.log((counter());  // 2
```

## 클로저를 응용한 예제

```jsx
function Person(name,age) {
	var _name = name;
	var _age = age;
	return {
		getName: function() { return _name; },
		getAge: function() { return _age; },
		setAge: function(x) { _age = x; }
	};
}
var person = Person("swan", 22);
console.log(person.getName());  // swan
console.log(person.getAge());   // 22
person.setAge(23);
console.log(person.getName();   // 23
```

```jsx
function makeMultiplier(x) {
  return function (y) {
    return x * y;
  };
}
var multi2 = makeMultiplier(2);
var multi10 = makeMultiplier(10);
console.log(multi2(3)); // 6
console.log(multi10(3)); // 30
```

- **잘못 사용한 예 : 반복문 안에서 클로저 만들기**

```jsx
var elm = 태그이름;
// elm.length = 3 이라고 가정함.
for (var i = 0; i < elm.length; i++) {
  elm[i].onclick = function () {
    console.log(i);
  };
}
```

3개의 onclick 이벤트 처리기가 선언되고 for문이 끝난 시점에서 이벤트가 동작되기 때문에console.log(i)가 실행하게 된다. 여기서 3개의 함수는 바깥에 있는 변수 i를 참조하는 클로저가 되었기 때문에 클로저가 공유하는 변수 i값이 3이 된다.

- **해결방법**

```jsx
for (var i = 0; i < elm.length; i++)
  (function (_i) {
    elm[_i].onclick = function () {
      console.log(_i);
    };
  })(i);
```

```jsx
for (let i = 0; i < elm.length; i++) {
  elm[i].onclick = function () {
    console.log(i);
  };
}
```

```jsx
for (var _i = 0; _i < elm.length; _i++) {
  let i = _i;
  elm[i].onclick = function () {
    console.log(i);
  };
}
```

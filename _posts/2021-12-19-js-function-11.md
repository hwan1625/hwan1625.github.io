---
layout: post
title: "[8.11] ECMAScript 6부터 추가된 함수의 기능"
---

| 추가된 함수               | 기능 |
| ------------------------- | ---- |
| 화살표 함수               |      |
| 나머지 매개변수           |      |
| 인수의 기본값             |      |
| 이터레이터                |      |
| 제너레이터                |      |
| 템플릿 리터럴의 태그 함수 |      |

## 화살표 함수 표현식으로 함수 정의하기

---

화살표 함수 표현식은 함수 리터럴(익명 함수)의 단축 표현이다.

`var multi = (x, y) ⇒ { return x*y; };`

인수가 하나만 있으면 인수를 묶는 괄호를 생략할 수 있다.

`var multi = x ⇒ { return x*x; };`

인수가 없으면 인수를 묶는 괄호를 생략할 수 없다.

`var f = () ⇒ { ... };`

함수 몸통 안의 문장이 `rerturn` 뿐이면 중괄호와 `return` 키워드를 생략할 수 있다.

`var multi = x ⇒ x*x;`

함수 몸통 안에 return 문장만 있더라도 함수의 반환값이 객체 리터럴이면 객체 리터럴을 그룹 연산자인 `()` 로 묶어야 한다.

`var f = (a, b) ⇒ ( {x: a, y: b} );`

화살표 함수도 즉시 실행 함수(IIFE)로 사용할 수 있다.

`(x ⇒ x*x)(3);`

**함수 리터럴과 화살표 함수의 차이점**

- `this` 의 값이 함수를 정의할 때 결정된다.
  함수 리터럴로 정의한 함수의 `this` 값은 함수를 호출할 때 결정된다. 그러나 화살표 함수의 `this` 값은 함수를 정의할 때 결정된다. 즉, 화살표 함수 바깥의 `this` 값이 화살표 함수의 `this` 값이 된다.
  ```jsx
  var obj = {
    say: function () {
      console.log(this); // [object Object]
      var f = function () {
        console.log(this);
      }; // [object Window]
      f();
      var g = () => console.log(this); // [object Object]
      g();
    },
  };
  ```
  함수 `f`는 `say`라는 함수의 중첩 함수이며 `this` 의 값은 전역 객체를 가리킨다. 한편 화살표 함수 `g`의 `this` 값은 함수 `g`를 정의한 익명 함수의 `this`의 값인 객체 `obj`를 가리킨다.
  화살표 함수는 `call`이나 `apply` 메서드를 사용해도 `this` 값은 바뀌지 않는다.
- arguments 변수가 없다.
- 생성자로 사용할 수 없다. (new 연산자 사용할 수 없음)
- yield 키워드를 사용할 수 없다. (제너레이터로 사용할 수 없다.)

## 인수에 추가된 기능

---

- 나머지 매개변수
  함수의 인자가 들어가는 부분에 `...` 을 입력하면 그만큼의 인수를 배열로 받을 수 있다.
  `function f(a, b, ...args) { console.log(a, b, args); }`
  이전까지는 배열이 아닌 유사 배열 객체인 `arguments` 변수를 사용하였기 때문에 배열로 변환해야 하는 것이 번거로웠지만 나머지 매개변수는 인수를 배열로 받기 때문에 덜 번거롭다.
- 인수의 기본값
  함수의 인자에 대입`=` 연산자를 사용해서 기본값을 설정할 수 있다.
  `function multiply(a, b=1) { return a*b;}`
  인수를 생략하거나 `undefined`를 넘기면 기본값으로 설정된다.

## 이터레이터와 for/of 문

---

**이터레이션**은 반복 처리라는 뜻으로 데이터 안의 요소를 연속적으로 꺼내는 행위를 말한다.

**이터레이터**란 반복 처리가 가능한 객체를 말한다.

```jsx
var a = [5, 4, 3];
var iter = a[Symbol.iterator]();
console.log(iter.next()); // Object {value: 5, done: false}
console.log(iter.next()); // Object {value: 4, done: false}
console.log(iter.next()); // Object {value: 3, done: false}
console.log(iter.next()); // Object {value: undefined, done: true}
console.log(iter.next()); // Object {value: undefined, done: true}
```

`iter`의 `next` 메서드를 호출할 때마다 **이터레이터 리절트**라는 객체가 반환된다.

이터레이터를 사용하여 이터레이션(반복)을 하려면 아래의 코드처럼 작성해야 한다.

```jsx
var a = [5, 4, 3];
var iter = a[Symbol.iterator]();
while (true) {
  var iteratorResult = iter.next();
  if (iteratorResult.done == true) break;
  var v = iteratorResult.value;
  console.log(v);
}
```

다행히도 `for/of` 문을 사용하면 이러한 반복 처리를 자동으로 하도록 만들 수 있다.

```jsx
var a = [5, 4, 3];
for (var v of a) console.log(v);
```

`Symbol.iterator` 메서드를 가진 객체를 반복 가능한(iterable) 객체라고 한다.

`Array` `String` `TypedArray` `Map` `Set`

`Symbol.iterator` 메서드를 가지고 있지 않으면 `for/of` 문으로는 순회할 수 없다.

## 제너레이터

---

- 반복 가능한 이터레이터를 값으로 반환한다.
- 작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리한다.

제너레이터는 이터레이터의 반복 처리를 강력하게 지원한다.

제너레이터는 `function*` 문으로 정의한 함수이며, 하나 이상의 `yield` 표현식을 포함한다.

```jsx
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
var iter = gen();
console.log(iter.next()); // Object {value: 1, done: false}
console.log(iter.next()); // Object {value: 2, done: false}
console.log(iter.next()); // Object {value: 3, done: false}
console.log(iter.next()); // Object {value: undefined, done: true}
```

`yield` 표현식은 `yield`에 지정한 표현식을 값으로 가지며 이 자체를 변수에 대입할 수 있다.

`var a = yield 2;`

제너레이터로 생성한 이터레이터는 이터러블하기 때문에 for/of 문을 사용할 수 있다.

`for(var v of iter) console.log(v);`

```jsx
function* createNumbers(from, to) {
  while (from <= to) yield from++;
}
var iter = createNumbers(10, 20);
for (var v of iter) console.log(v); // 10~20 사이의 정수를 순서대로 출력
```

**제너레이터 종료하기 : `return` 메서드**

제너레이터로 생성한 이터레이터의 `return` 메서드를 실행하면 인수 값을 반환한 후에 제너레이터를 종료한다.

```jsx
function* g() {
  yield 1;
  yield 2;
  yield 3;
}
var iter = g();
iter.next(); // Object {value: 1, done:false}
iter.return(10); // Object {value: 10, done: true
iter.next(); // Objcet {value: undefined, done: true}
```

**제너레이터에 예외 던저기 : `throw` 메서드**

제너레이터의 예외는 일반적으로 `try-catch` 문으로 받아서 처리한다.

```jsx
function* f() {
  while (true) {
    try {
      // 실행할 코드
    } catch (e) {
      console.log("오류가 발생했습니다.");
    }
  }
}
var iter = f();
iter.throw(new Error("오류")); // 오류가 발생했습니다.
```

**반복 가능한 객체에 위임하기 : `yield*`**

```jsx
function* f() {
  yield "X";
  yield "Y";
}
function* g() {
  yield 0;
  yield* [2, 4];
  yield* "AB";
  yield* f();
}
var iter = g();
for (var v of iter) console.log(v); // 0, 2, 4, A, B, X, Y
```

## 템플릿 리터럴의 태그 함수

---

`func`${a} + ${b} = ${a+b}``

`func` 부분을 ‘태그 함수’라고 한다. 태그 함수의 첫 번째 인수는 문자열을 요소로 담은 배열이다. 이 배열의 요소는 템플릿 리터럴 안의 문자열을 `${...}`를 기준으로 분할한 문자열이다. 두 번째 이후 인수로는 각 `${...}` 안에 지정된 표현식을 평가한 값이 순서대로 들어간다. 태그 함수의 반환값은 그 어떤 값도 가능하다.

```jsx
function list() { return arguments; }
var t = list`a${1}b${2}c${3};
console.log(t);  // [["a", "b", "c", ""], 1, 2, 3]
```

```jsx
function htmlEscape(strings, ...values) {
  var result = strings[0];
  for (var i = 0; i < values.length; i++) {
    result += escape(values[i]) + strings[i + 1];
  }
  return result;
  function escape(s) {
    return s
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/'/g, "&#039;")
      .replace(/"/g, "&quot;")
      .replace(/`/g, "&#096;");
  }
}
var userinput = "<script>alert('test');</script>";
var message = htmlEscape`<p>${userinput}</p>`;
console.log(message);
```

태그 함수의 첫 번째 인수는 `callSite` 객체라고 하며 다음과 같은 특징이 있다.

- 동결되어 있다. (읽기만 할 수 있다. 프로퍼티 추가, 삭제, 변경 불가능)
- `callSite` 객체는 캐시된다.
  태그 함수는 이전에 처리했던 템플릿 리털러 문자열을 만나면 캐시도니 `callSite` 객체를 첫 번째 인수로 넘긴다.
- `raw` 프로퍼티가 있다.
  `raw` 프로퍼티 값은 배열이며 그 요소 첫 번째 인수의 배열과 마찬가지로 템플릿 리터럴을 `${...}`로 분할한 문자열이다. `raw` 프로퍼티에는 이스케이프되지 않은 문자열이 들어온다.
  ```jsx
  function tag(strings, ...values) {
    console.log(strings); // ['a\n', 'b\n', 'c', '', raw: Array(4)]
    console.log(strings.raw); // ['a\\n', 'b\\n', 'c', '']
  }
  tag`a\n${1}b\n${2}c${3}`;
  ```
